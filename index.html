<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Work Athlete Dashboard</title>
<style>
  :root {
    --bg: #ffffff;
    --fg: #111111;
    --muted: #666666;
    --border: #e7e7e7;
    --accent: #8f4dcc;   /* Brandwell purple */
    --accent-2: #2ec4b6; /* Teal */
    --radius: 12px;
    --shadow: 0 6px 24px rgba(0,0,0,0.06);
    --container: 900px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --sans: Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, sans-serif;
  }

  * { box-sizing: border-box; }

  html, body {
    background: var(--bg);
    color: var(--fg);
    font-family: var(--sans);
    line-height: 1.55;
    margin: 0;
  }

  header {
    padding: 2rem 1.25rem 1rem;
    border-bottom: 1px solid var(--border);
    background: #fafafa;
  }

  h1 {
    margin: 0 0 0.35rem;
    font-size: clamp(1.6rem, 3.4vw, 2.2rem);
  }

  .date {
    color: var(--muted);
    font-size: 0.95rem;
  }

  main {
    max-width: var(--container);
    margin: 0 auto;
    padding: 2rem 1.25rem 6rem;
  }

  .actions {
    display: flex;
    flex-wrap: wrap;
    gap: .6rem;
    margin: 1.2rem 0 2rem;
  }

  button, .btn {
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: #fff;
    color: var(--fg);
    padding: 0.65rem 1rem;
    font-weight: 600;
    cursor: pointer;
    box-shadow: var(--shadow);
    transition: transform .15s ease, box-shadow .15s ease, border-color .15s ease;
  }
  button:hover, .btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 28px rgba(0,0,0,.08);
    border-color: var(--accent);
  }

  button.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  button.primary:hover {
    box-shadow: 0 8px 28px rgba(143,77,204,0.25);
  }

  button.outline-danger {
    border-color: #ff4d4f33;
    color: #ff4d4f;
    background: #fff;
  }

  .set {
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 1rem 1rem 0.75rem;
    margin-bottom: 1rem;
    background: #fff;
  }

  .set-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: .75rem;
    flex-wrap: wrap;
    gap: .5rem;
  }

  .set-title {
    font-weight: 600;
  }

  .set-time {
    font-size: 0.85rem;
    color: var(--muted);
  }

  .timer {
    display: flex;
    align-items: center;
    gap: .5rem;
    margin: .4rem 0 .8rem;
    flex-wrap: wrap;
  }

  .timer-display {
    font-family: var(--mono);
    font-size: 1.05rem;
    font-weight: 600;
    padding: .2rem .5rem;
    border-radius: 6px;
    background: #f5f5f5;
    border: 1px solid var(--border);
  }

  .checks {
    display: flex;
    gap: 1rem;
    margin: 0.5rem 0 0.75rem;
    flex-wrap: wrap;
  }

  .checks label {
    display: flex;
    align-items: center;
    gap: 0.45rem;
    cursor: pointer;
  }

  textarea {
    width: 100%;
    min-height: 90px;
    resize: vertical;
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.6rem 0.75rem;
    font-family: var(--sans);
    font-size: 0.95rem;
  }
  textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(143,77,204,0.12);
  }

  .summary {
    margin: 1.8rem 0 2.2rem;
    padding: 1rem;
    border-left: 4px solid var(--accent-2);
    background: #f7fffe;
    border-radius: 6px;
  }

  details.manifesto {
    margin-top: 3rem;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    background: #fff;
  }

  details summary {
    list-style: none;
    cursor: pointer;
    padding: 1rem 1.2rem;
    font-weight: 600;
    border-bottom: 1px solid var(--border);
  }

  details[open] summary {
    border-bottom: 1px solid var(--border);
  }

  details .content {
    padding: 1.2rem 1.2rem 1.8rem;
  }

  .mono {
    font-family: var(--mono);
  }

  /* Print styles only affect window.print() flows – not used now, but keeping tidy */
  @media print {
    header, .actions, details.manifesto summary, #motivation-toggle {
      display: none !important;
    }
    body {
      background: #fff !important;
      color: #000;
    }
    main {
      padding: 0 0 0 0;
      max-width: none;
    }
    .set {
      box-shadow: none !important;
      page-break-inside: avoid;
    }
    details.manifesto {
      border: none;
      box-shadow: none;
    }
  }
</style>
</head>
<body>
<header>
  <h1>Work Athlete Dashboard</h1>
  <div class="date" id="todayStr"></div>
</header>

<main>
  <div class="actions">
    <button class="primary" id="addSetBtn">+ Add Set</button>
    <button id="exportBtn">Export Day (PDF)</button>
    <button id="resetBtn" class="outline-danger">Reset Today</button>
  </div>

  <!-- Everything we want in the PDF lives inside exportArea -->
  <div id="exportArea">
    <div class="summary" id="summary"></div>
    <div id="setsContainer"></div>
  </div>

  <details class="manifesto" id="motivation">
    <summary>Why this system works (Work Athlete Manifesto)</summary>
    <div class="content">
      <h2 style="margin-top:0">The Work Athlete Manifesto</h2>
      <p><strong>Sets build strength. Systems build empires.</strong></p>
      <ol>
        <li><strong>Reps Create Results</strong> — Every 30-minute sprint is a rep for your future self.</li>
        <li><strong>Sets Create Systems</strong> — One set moves the ball. Three sets make a session. Four sessions a day builds the machine.</li>
        <li><strong>Momentum &gt; Motivation</strong> — Start the clock, do the work. The set creates the energy, not the other way around.</li>
        <li><strong>Time, Not Tasks</strong> — Tasks are unpredictable; 30-minute blocks are guaranteed progress.</li>
        <li><strong>Recovery Is Growth</strong> — 5 minutes of movement post-set resets your nervous system and sharpens the next block.</li>
        <li><strong>Fitness + Focus = One Loop</strong> — Work + Workout form a closed, self-reinforcing cycle.</li>
        <li><strong>Structure = Freedom</strong> — 4 sessions = 12 sets = ~6 hours of elite output + 60 minutes of movement.</li>
        <li><strong>Volume Is King</strong> — Consistency > intensity. Reps compound into legacy.</li>
        <li><strong>Consistency Destroys Resistance</strong> — Even on bad days, one set keeps the system alive.</li>
        <li><strong>You Are the Machine</strong> — Refine the loop, refine yourself.</li>
      </ol>
      <p><em>Tagline:</em> <strong>“Reps build strength. Sets build systems. Systems build legacies.”</strong></p>
    </div>
  </details>
</main>

<!-- html2pdf for client-side PDF download -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js" integrity="sha512-YcsIPFd6Z4S1f1Z4YWgq5vDma2xEabLlLHce4u8dkWQMRs3Uhw2+o3HSuYk9t1KVk6iXW9eFh0bX2bMZr3K1fQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
/**
 * Work Athlete Dashboard MVP v2
 * - Per-day persistence: localStorage key = 'wa-YYYY-MM-DD'
 * - Per-set 30:00 timers (with persistence)
 * - Export to PDF (download) via html2pdf.js
 */

(function () {
  const DEFAULT_DURATION = 30 * 60; // 30 min in seconds

  const todayKey = getTodayKey();
  const storageKey = 'wa-' + todayKey;

  const setsContainer = document.getElementById('setsContainer');
  const addSetBtn = document.getElementById('addSetBtn');
  const exportBtn = document.getElementById('exportBtn');
  const resetBtn = document.getElementById('resetBtn');
  const todayStr = document.getElementById('todayStr');
  const summaryEl = document.getElementById('summary');
  const exportArea = document.getElementById('exportArea');

  todayStr.textContent = new Date().toLocaleDateString(undefined, {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  let state = loadDay() || defaultState();

  // Store active intervals to avoid duplicates
  const intervals = new Map();

  renderAll();
  updateSummary();

  // --- Event bindings ---
  addSetBtn.addEventListener('click', () => {
    state.sets.push(newSet());
    saveDay();
    renderAll();
    updateSummary();
    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
  });

  exportBtn.addEventListener('click', () => {
    const filename = `WA-${todayKey}.pdf`;
    const opt = {
      margin: 0.4,
      filename,
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { scale: 2, useCORS: true },
      jsPDF: { unit: 'in', format: 'letter', orientation: 'portrait' }
    };
    html2pdf().from(exportArea).set(opt).save();
  });

  resetBtn.addEventListener('click', () => {
    const ok = confirm('Reset today? This will clear all sets logged for ' + todayKey + '.');
    if (!ok) return;
    state = defaultState();
    clearAllIntervals();
    saveDay(true);
    renderAll();
    updateSummary();
  });

  // --- Helpers ---
  function getTodayKey() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const dd = String(d.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  }

  function defaultState() {
    return {
      date: todayKey,
      sets: [newSet()]
    };
  }

  function newSet() {
    return {
      id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now() + Math.random()),
      createdAt: new Date().toISOString(),
      workDone: false,
      workoutDone: false,
      notes: '',
      timer: {
        duration: DEFAULT_DURATION,
        remaining: DEFAULT_DURATION,
        running: false,
        startedAt: null
      }
    };
  }

  function loadDay() {
    try {
      const raw = localStorage.getItem(storageKey);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!(parsed && parsed.date === todayKey && Array.isArray(parsed.sets))) return null;

      // Recompute timers if they were running
      const now = Date.now();
      parsed.sets.forEach(s => {
        if (!s.timer) {
          s.timer = { duration: DEFAULT_DURATION, remaining: DEFAULT_DURATION, running: false, startedAt: null };
        } else if (s.timer.running && s.timer.startedAt) {
          const elapsed = Math.floor((now - new Date(s.timer.startedAt).getTime()) / 1000);
          s.timer.remaining = Math.max(0, s.timer.remaining - elapsed);
          s.timer.running = s.timer.remaining > 0; // stop if over
          if (s.timer.remaining <= 0) s.timer.startedAt = null;
          else s.timer.startedAt = new Date(now).toISOString(); // re-anchor to now
        }
      });

      return parsed;
    } catch (e) {
      console.warn('Failed to load day', e);
      return null;
    }
  }

  function saveDay(clear = false) {
    try {
      if (clear) {
        localStorage.removeItem(storageKey);
      } else {
        localStorage.setItem(storageKey, JSON.stringify(state));
      }
    } catch (e) {
      console.warn('Failed to save day', e);
    }
  }

  function renderAll() {
    setsContainer.innerHTML = '';
    clearAllIntervals();

    state.sets.forEach((s, idx) => {
      setsContainer.appendChild(renderSet(s, idx));
    });
  }

  function renderSet(s, index) {
    const wrap = document.createElement('div');
    wrap.className = 'set';

    // header
    const header = document.createElement('div');
    header.className = 'set-header';

    const title = document.createElement('div');
    title.className = 'set-title';
    title.textContent = `Set ${index + 1}`;

    const timestamp = document.createElement('div');
    timestamp.className = 'set-time';
    timestamp.textContent = formatTime(s.createdAt);

    header.appendChild(title);
    header.appendChild(timestamp);

    // timer
    const timerWrap = document.createElement('div');
    timerWrap.className = 'timer';

    const display = document.createElement('span');
    display.className = 'timer-display';
    display.textContent = formatSeconds(s.timer.remaining);

    const startBtn = document.createElement('button');
    startBtn.textContent = s.timer.running ? 'Running…' : 'Start';
    startBtn.disabled = s.timer.running;
    startBtn.addEventListener('click', () => {
      if (!s.timer.running && s.timer.remaining > 0) {
        s.timer.running = true;
        s.timer.startedAt = new Date().toISOString();
        saveDay();
        startTimerInterval(s, display, startBtn, pauseBtn, resetBtn);
        startBtn.disabled = true;
        startBtn.textContent = 'Running…';
      }
    });

    const pauseBtn = document.createElement('button');
    pauseBtn.textContent = 'Pause';
    pauseBtn.disabled = !s.timer.running;
    pauseBtn.addEventListener('click', () => {
      if (s.timer.running) {
        pauseTimer(s);
        saveDay();
        display.textContent = formatSeconds(s.timer.remaining);
        startBtn.disabled = false;
        startBtn.textContent = 'Resume';
        pauseBtn.disabled = true;
      }
    });

    const resetBtn = document.createElement('button');
    resetBtn.textContent = 'Reset';
    resetBtn.addEventListener('click', () => {
      pauseTimer(s);
      s.timer.remaining = s.timer.duration;
      s.timer.startedAt = null;
      saveDay();
      display.textContent = formatSeconds(s.timer.remaining);
      startBtn.disabled = false;
      startBtn.textContent = 'Start';
      pauseBtn.disabled = true;
    });

    timerWrap.appendChild(display);
    timerWrap.appendChild(startBtn);
    timerWrap.appendChild(pauseBtn);
    timerWrap.appendChild(resetBtn);

    // if timer was already running, restart interval
    if (s.timer.running) {
      startTimerInterval(s, display, startBtn, pauseBtn, resetBtn);
      startBtn.disabled = true;
      startBtn.textContent = 'Running…';
      pauseBtn.disabled = false;
    }

    // checks
    const checks = document.createElement('div');
    checks.className = 'checks';

    const workLabel = document.createElement('label');
    const workCheckbox = document.createElement('input');
    workCheckbox.type = 'checkbox';
    workCheckbox.checked = !!s.workDone;
    workCheckbox.addEventListener('change', () => {
      s.workDone = workCheckbox.checked;
      saveDay();
      updateSummary();
    });
    workLabel.appendChild(workCheckbox);
    workLabel.appendChild(document.createTextNode('30-min Work Complete'));

    const workoutLabel = document.createElement('label');
    const workoutCheckbox = document.createElement('input');
    workoutCheckbox.type = 'checkbox';
    workoutCheckbox.checked = !!s.workoutDone;
    workoutCheckbox.addEventListener('change', () => {
      s.workoutDone = workoutCheckbox.checked;
      saveDay();
      updateSummary();
    });
    workoutLabel.appendChild(workoutCheckbox);
    workoutLabel.appendChild(document.createTextNode('Movement / Workout Done'));

    checks.appendChild(workLabel);
    checks.appendChild(workoutLabel);

    // notes
    const notes = document.createElement('textarea');
    notes.placeholder = 'What did you do in this set?';
    notes.value = s.notes || '';
    notes.addEventListener('input', () => {
      s.notes = notes.value;
      saveDay();
    });

    wrap.appendChild(header);
    wrap.appendChild(timerWrap);
    wrap.appendChild(checks);
    wrap.appendChild(notes);

    return wrap;
  }

  function updateSummary() {
    const total = state.sets.length;
    const workDone = state.sets.filter(s => s.workDone).length;
    const workoutDone = state.sets.filter(s => s.workoutDone).length;

    const hoursFocused = (workDone * 30) / 60;
    const minsFocused = workDone * 30;

    const minsMoved = workoutDone * 5; // adjust if you want

    summaryEl.innerHTML = `
      <strong>Today’s Tally</strong><br/>
      Sets logged: <strong>${total}</strong><br/>
      Work sets completed: <strong>${workDone}</strong> (${minsFocused} mins / ${hoursFocused.toFixed(1)} hrs)<br/>
      Movement sets completed: <strong>${workoutDone}</strong> (${minsMoved} mins est.)<br/>
      <span class="mono">${storageKey}</span>
    `;
  }

  function formatTime(iso) {
    try {
      const d = new Date(iso);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch (e) {
      return '';
    }
  }

  function formatSeconds(sec) {
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  }

  function startTimerInterval(s, display, startBtn, pauseBtn, resetBtn) {
    // clear any existing
    stopInterval(s.id);

    pauseBtn.disabled = false;

    const id = setInterval(() => {
      const now = Date.now();
      const started = new Date(s.timer.startedAt).getTime();
      const elapsed = Math.floor((now - started) / 1000);

      s.timer.remaining = Math.max(0, s.timer.duration - elapsed - (s.timer.duration - s.timer.remaining));
      // the formula above accounts for a resumed timer (remaining already discounted)
      // simpler: track "remaining" decreasing each tick instead of recomputing,
      // but this keeps it robust to tab sleep. Let's just decrement directly:

      // Actually, simpler:
      s.timer.remaining = s.timer.remaining - 1;

      if (s.timer.remaining <= 0) {
        s.timer.remaining = 0;
        s.timer.running = false;
        s.timer.startedAt = null;
        clearInterval(id);
        intervals.delete(s.id);
        startBtn.disabled = false;
        startBtn.textContent = 'Restart';
        pauseBtn.disabled = true;
      }

      display.textContent = formatSeconds(s.timer.remaining);
      saveDay();
    }, 1000);

    intervals.set(s.id, id);
  }

  function pauseTimer(s) {
    s.timer.running = false;
    if (s.timer.startedAt) {
      // compute remaining properly at pause time
      // but since we're decrementing every second, we can just stop here.
      s.timer.startedAt = null;
    }
    stopInterval(s.id);
  }

  function stopInterval(id) {
    if (intervals.has(id)) {
      clearInterval(intervals.get(id));
      intervals.delete(id);
    }
  }

  function clearAllIntervals() {
    for (const [id, intId] of intervals) {
      clearInterval(intId);
    }
    intervals.clear();
  }
})();
</script>
</body>
</html>
